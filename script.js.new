// DOM Elements
const pixelGrid = document.getElementById('pixelGrid');
const colorPicker = document.getElementById('colorPicker');
const colorValue = document.getElementById('colorValue');
const colorPalette = document.getElementById('colorPalette');

// State
let currentColor = '#000000';
let gridWidth = 16;
let gridHeight = 16;
let isMouseDown = false;

// Default color palette
const defaultColors = [
    '#000000', '#ffffff', '#ff0000', '#00ff00', 
    '#0000ff', '#ffff00', '#00ffff', '#ff00ff',
    '#808080', '#800000', '#808000', '#008000',
    '#800080', '#008080', '#000080'
];

// Initialize the app
function init() {
    // Set up event listeners
    colorPicker.addEventListener('input', updateCurrentColor);
    document.addEventListener('mousedown', () => isMouseDown = true);
    document.addEventListener('mouseup', () => isMouseDown = false);
    
    // Initialize color palette
    defaultColors.forEach(color => addColorToPalette(color));
    
    // Set default grid size
    setPresetGridSize(16);
}

// Set the grid size with width and height
function setGridSize(width, height) {
    gridWidth = width;
    gridHeight = height;
    renderGrid();
}

// Set preset grid size (square)
function setPresetGridSize(size) {
    gridWidth = size;
    gridHeight = size;
    document.getElementById('customWidth').value = size;
    document.getElementById('customHeight').value = size;
    renderGrid();
}

// Set custom grid size from inputs
function setCustomGridSize() {
    const width = parseInt(document.getElementById('customWidth').value);
    const height = parseInt(document.getElementById('customHeight').value);
    
    // Validate inputs
    if (isNaN(width) || isNaN(height) || width < 4 || height < 4 || width > 100 || height > 100) {
        alert('Please enter valid dimensions between 4 and 100');
        return;
    }
    
    setGridSize(width, height);
}

// Render the pixel grid
function renderGrid() {
    pixelGrid.innerHTML = '';
    
    // Create grid container
    const gridContainer = document.createElement('div');
    gridContainer.className = 'grid';
    gridContainer.style.display = 'grid';
    gridContainer.style.gridTemplateColumns = `repeat(${gridWidth}, 1fr)`;
    gridContainer.style.gap = '0';
    
    // Create pixels
    for (let i = 0; i < gridWidth * gridHeight; i++) {
        const pixel = document.createElement('div');
        pixel.className = 'pixel bg-white';
        pixel.dataset.index = i;
        
        // Add event listeners for click and drag
        pixel.addEventListener('mousedown', handlePixelClick);
        pixel.addEventListener('mouseover', handlePixelHover);
        
        // Prevent drag selection
        pixel.addEventListener('dragstart', (e) => e.preventDefault());
        
        gridContainer.appendChild(pixel);
    }
    
    pixelGrid.appendChild(gridContainer);
}

// Handle pixel click
function handlePixelClick(e) {
    if (e.button !== 0) return; // Only left click
    
    const pixel = e.target;
    pixel.style.backgroundColor = currentColor;
    
    // Add click animation
    pixel.classList.add('pixel-click');
    setTimeout(() => pixel.classList.remove('pixel-click'), 200);
}

// Handle pixel hover (for click and drag)
function handlePixelHover(e) {
    if (isMouseDown) {
        const pixel = e.target;
        pixel.style.backgroundColor = currentColor;
    }
}

// Update the current color
function updateCurrentColor() {
    currentColor = colorPicker.value;
    colorValue.textContent = currentColor;
    
    // Update active state in palette
    document.querySelectorAll('.color-swatch').forEach(swatch => {
        swatch.classList.toggle('active', swatch.style.backgroundColor === currentColor);
    });
}

// Add a color to the palette
function addToPalette() {
    const color = colorPicker.value;
    if (!defaultColors.includes(color)) {
        addColorToPalette(color);
    }
}

// Add a color to the palette UI
function addColorToPalette(color) {
    if (document.querySelector(`.color-swatch[data-color="${color}"]`)) return;
    
    const swatch = document.createElement('div');
    swatch.className = 'color-swatch';
    swatch.style.backgroundColor = color;
    swatch.dataset.color = color;
    swatch.title = color;
    
    swatch.addEventListener('click', () => {
        colorPicker.value = color;
        updateCurrentColor();
    });
    
    colorPalette.insertBefore(swatch, colorPalette.firstChild);
}

// Export the pixel art as PNG
function exportImage() {
    const gridContainer = pixelGrid.querySelector('.grid');
    if (!gridContainer) return;
    
    // Create a canvas element
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    // Set canvas size (20px per pixel)
    const pixelSize = 20;
    canvas.width = gridWidth * pixelSize;
    canvas.height = gridHeight * pixelSize;
    
    // Fill with white background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw each pixel
    const pixels = gridContainer.querySelectorAll('.pixel');
    pixels.forEach((pixel, index) => {
        const row = Math.floor(index / gridWidth);
        const col = index % gridWidth;
        
        // Get computed style to handle default white background
        const bgColor = window.getComputedStyle(pixel).backgroundColor;
        
        ctx.fillStyle = bgColor || '#ffffff';
        ctx.fillRect(col * pixelSize, row * pixelSize, pixelSize, pixelSize);
    });
    
    // Create download link
    const link = document.createElement('a');
    link.download = `pixel-art-${new Date().getTime()}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
}

// Initialize the app when the DOM is loaded
document.addEventListener('DOMContentLoaded', init);
